
Domain Poller {
	Subdomain EvaluationDomain {
		domainVisionStatement = "Evaluation domain vision ..."
	}

	Subdomain SkillDomain {
		domainVisionStatement = "Skill domain vision ..."
	}

	Subdomain QuestionDomain {
		domainVisionStatement = "Question domain vision ..."
	}

	Subdomain StatDomain {
		domainVisionStatement = "Stat domain vision ..."
	}

}

ContextMap Poller {
	contains QuestionContext
	contains SkillContext
	contains UserAnswerContext
	contains SendQuestionContext
	contains UserManagementContext
	contains EvaluationContext
	contains StatContext

	// Links doc : https://contextmapper.org/docs/language-model/#links
	QuestionContext [S]->[C] SendQuestionContext

	QuestionContext [P]<->[P] SkillContext

	UserManagementContext [U, OHS, PL]->[D, ACL] QuestionContext

	UserManagementContext [U, OHS, PL]->[D, ACL] UserAnswerContext

	UserManagementContext [U, OHS, PL]->[D, ACL] SkillContext

	SendQuestionContext [S]->[C] UserAnswerContext

	QuestionContext [U, OHS, PL]->[D, ACL] UserAnswerContext

	UserAnswerContext [S]->[C] EvaluationContext

	SkillContext [U, OHS, PL]->[D, ACL] EvaluationContext

	EvaluationContext [U, OHS, PL]->[D, ACL] StatContext
}

BoundedContext QuestionContext implements SkillDomain {
	Application {
		Command AssociateQuestion
		Command AcceptQuestion
		Command RejectQuestion
		Command CreateQuestionData
		/* For event trigger in flow :
		 *   X: alternative command invokation (exclusive; only one); 
		 *   +: concurrent command invokation (all commands called); 
		 *   O: alternative command invokation (inclusive; one or multiple)
		 */
		Flow AssociateQuestionFlow {
			command AssociateQuestion delegates to Question [WAITING -> WAITING] emits event QuestionWaitingForAssociation
			event QuestionWaitingForAssociation triggers command AcceptQuestion X RejectQuestion
			command AcceptQuestion delegates to Question [WAITING -> ASSOCIATED] emits event QuestionAcceptedAssociation
			command RejectQuestion delegates to Question [WAITING -> REFUSED] emits event QuestionRefusedAssociation
			event QuestionAcceptedAssociation triggers command CreateQuestionData
		}
	}

	Module questionAdmin {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Question {
			Entity QuestionResource {
				aggregateRoot
				String questionContent
				- @States questionState
				- @Types resourceType
				- Tag tag
			}
			enum Types {
				IMG_URL, URL, TEXT
			}
			enum States {
				aggregateLifecycle
				WAITING, ASSOCIATED, REFUSED
			}
			DomainEvent QuestionWaitingForAssociation {
				- QuestionResource questionId
				- TagId tagId
			}
			DomainEvent QuestionAcceptedAssociation {
				- QuestionResource questionId
				- TagId tagId
			}
			DomainEvent QuestionRefusedAssociation {
				- QuestionResource questionId
				- TagId tagId
			}
			ValueObject QuestionId {
				int questionId key
			}
		}
	}
}

BoundedContext SkillContext {
	Application {
		Command CreateTag
		Command CreateCategory
		Flow CreateSkillFlow {
			command CreateTag delegates to Skill [CREATED -> CREATED] emits event TagCreated
			command CreateCategory emits event CategoryCreated
		}
	}

	Module skill {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Skill {
			Entity Tag {
				aggregateRoot
				- TagId id
				String name
				- @Category category
				- @User createdBy
			}
			ValueObject TagId {
				int tagId key
			}
			enum TagStates {
				aggregateLifecycle
				CREATED, DELETED
			}
			Entity Category {
				- CategoryId identifier
				String name
				String description
				- List<@Tag> tags
				- @User createdBy
			}
			enum CategoryEvents {
				CREATED, DELETED
			}
			ValueObject CategoryId {
				int categoryId key
			}
			DomainEvent TagCreated {
				- TagId tagId
			}
			DomainEvent CategoryCreated {
				- CategoryId categoryId
			}
		}
	}
}

BoundedContext SendQuestionContext implements QuestionDomain {
	Module location {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate UserWithPreferences {
			Entity UserWithPreferences {
				aggregateRoot
				- UserId user
				- List<TagId> preferences
			}
		}
		Aggregate QuestionNotification {
			Entity Notification {
				- @QuestionId questionId
				- @TagId tagId
			}
		}
	// event to notify user interested in a tag
	}
}

BoundedContext UserAnswerContext implements QuestionDomain {
	Module question {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate UserAnswer {
			Entity UserAnswer {
				aggregateRoot
				- @TagId choosenAnswer
				- @User user
			}
		}
	}
}

BoundedContext EvaluationContext implements EvaluationDomain {
	Module evaluation {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate ScoreRule {
			Entity ScoreRule {
				aggregateRoot
				int malusWhenWrong
				int bonusWhenGood
			}
		}
		Aggregate Exercice {
			Entity Evaluation {
				aggregateRoot
				int score
				- @Status status
				- @UserAnswer userAnswer
			}
			enum Status {
				OPEN,
				DONE
			}
		}
	}
}

BoundedContext StatContext implements StatDomain {
	Module stat {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Stat {
			Entity LeaderBoard {
				aggregateRoot
				- List<ExerciceUserAndScore> userScores
			}
			ValueObject ExerciceUserAndScore {
				String userName
				int score
			}
		}
	}
}

BoundedContext UserManagementContext {
	Module user {
		Aggregate Users {
			Entity User {
				aggregateRoot
				String firstname
				String lastname
				- @Roles role
				- @UserStatus status
			}
			enum Roles {
				EVALUATOR, STUDENT
			}
			enum UserStatus {
				aggregateLifecycle
				VALIDATED, WAITING_VALIDATION
			}
			ValueObject UserId {
				Integer id
			}
		}
	}
}

