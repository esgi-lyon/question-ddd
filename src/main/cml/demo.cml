
Domain Gamedev {
	Subdomain EvaluationDomain {
		domainVisionStatement = "Evaluation domain vision ..."
	}

	Subdomain SkillDomain {
		domainVisionStatement = "Skill domain vision ..."
	}

	Subdomain QuestionDomain {
		domainVisionStatement = "Question domain vision ..."
	}

	Subdomain StatDomain {
		domainVisionStatement = "Stat domain vision ..."
	}

}

ContextMap Poller {
	contains QuestionContext
	contains SkillContext
	contains AnswerContext
	contains SendQuestionContext
	contains UserManagementContext
	contains EvaluationContext
	contains StatContext

	// Links doc : https://contextmapper.org/docs/language-model/#links
	QuestionContext [S]->[C] SendQuestionContext

	QuestionContext [P]<->[P] SkillContext

	SkillContext [S]->[C] SendQuestionContext

	UserManagementContext [U, OHS, PL]->[D, ACL] SendQuestionContext

	UserManagementContext [U, OHS, PL]->[D, ACL] QuestionContext

	UserManagementContext [U, OHS, PL]->[D, ACL] AnswerContext

	UserManagementContext [U, OHS, PL]->[D, ACL] SkillContext

	SendQuestionContext [S]->[C] AnswerContext

	AnswerContext [S]->[C] EvaluationContext

	SkillContext [U, OHS, PL]->[D, ACL] EvaluationContext

	EvaluationContext [S]->[C] StatContext
}

BoundedContext UserManagementContext {
	Module user {
		Aggregate User {
			Entity User {
				aggregateRoot
				String firstname
				String lastname
				- @Roles role
				- @UserStatus status
			}
			enum Roles {
				EVALUATOR, STUDENT
			}
			enum UserStatus {
				aggregateLifecycle
				VALIDATED, WAITING_VALIDATION
			}
			ValueObject UserId {
				Integer id
			}
		}
	}
}

BoundedContext QuestionContext implements SkillDomain {
	Application {
		Command AssociateQuestion
		Command AcceptQuestion
		Command RejectQuestion
		Command CreateQuestionData
		/* For event trigger in flow :
		 *   X: alternative command invokation (exclusive; only one); 
		 *   +: concurrent command invokation (all commands called); 
		 *   O: alternative command invokation (inclusive; one or multiple)
		 */
		Flow AssociateQuestionFlow {
			command AssociateQuestion delegates to Question [WAITING -> WAITING] emits event QuestionWaitingForAssociation
			event QuestionWaitingForAssociation triggers command AcceptQuestion X RejectQuestion
			command AcceptQuestion delegates to Question [WAITING -> ASSOCIATED] emits event QuestionAcceptedAssociation
			command RejectQuestion delegates to Question [WAITING -> REFUSED] emits event QuestionRefusedAssociation
			event QuestionAcceptedAssociation triggers command CreateQuestionData
		}
	}

	Module questionAdmin {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Question {
			Entity QuestionResource {
				aggregateRoot
				String questionContent
				- @States questionState
				- @Types resourceType
				- Tag tag
			}
			enum Types {
				IMG_URL, URL, TEXT
			}
			enum States {
				aggregateLifecycle
				WAITING, ASSOCIATED, REFUSED
			}
			DomainEvent QuestionWaitingForAssociation {
				- QuestionResource questionId
				- TagId tagId
			}
			DomainEvent QuestionAcceptedAssociation {
				- QuestionResource questionId
				- TagId tagId
			}
			DomainEvent QuestionRefusedAssociation {
				- QuestionResource questionId
				- TagId tagId
			}
			ValueObject QuestionResourceTag {
				- QuestionResource questionId
				- TagId tagId
			}
		}
	}
}

BoundedContext SkillContext {
	Application {
		Command CreateTag
		Command CreateCategory
		Flow CreateSkillFlow {
			command CreateTag delegates to Skill [CREATED -> CREATED] emits event TagCreated
			command CreateCategory emits event CategoryCreated
		}
	}

	Module skill {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Skill {
			Entity Tag {
				aggregateRoot
				- TagId id
				String name
				- @Category category
				- @User createdBy
			}
			ValueObject TagId {
				int tagId key
			}
			enum TagStates {
				aggregateLifecycle
				CREATED, DELETED
			}
			Entity Category {
				- CategoryId identifier
				String name
				String description
				- List<@Tag> tags
				- @User createdBy
			}
			enum CategoryEvents {
				CREATED, DELETED
			}
			ValueObject CategoryId {
				int categoryId key
			}
			DomainEvent TagCreated {
				- TagId tagId
			}
			DomainEvent CategoryCreated {
				- CategoryId categoryId
			}
		}
	}
}

BoundedContext SendQuestionContext implements QuestionDomain {
	// Ubiquitous Language for question notion is here a "notification"s
	Application {
		Command CreateQuestion
		Command SendQuestionByTagsPreferences
		Flow CreateChoiceFlow {
			// Randomized choice creation
			command CreateQuestion delegates to Question emits event CreatedQuestion
			event CreatedQuestion triggers command SendQuestionByTagsPreferences
			command SendQuestionByTagsPreferences delegates to Question emits event NotifiedQuestion
		}
	}

	Module sendQuestion {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate UserPreferences {
			Entity UserPreferences {
				aggregateRoot
				- UserId user
				- List<TagId> preferences
			}
		}
		Aggregate QuestionNotification {
			Entity QuestionSent {
				aggregateRoot
				// implicit valid choice in question
				- Question question
				- QuestionNotificationStatus status
			}
			enum QuestionNotificationStatus {
				aggregateLifecycle
				SENT, VIEWED, ANSWERED
			}

			DomainEvent CreatedQuestion {
				- QuestionSent questionAndTag
			}
			DomainEvent NotifiedQuestion {
				- QuestionSent questionResource
			}
			ValueObject Question {
				- List<QuestionResourceTag> resourcesWithRandomized
				- QuestionResourceTag validQuestionResources
			}
		}
	}
}

BoundedContext AnswerContext implements QuestionDomain {
	Application {
		Command TagChoicesList
		Command AnswerSubmit
		Flow ChoiceSubmitFlow {
			command TagChoicesList delegates to Question emits event TagChoicesListed
			command AnswerSubmit delegates to Question emits event AnswerSubmitted
		}
	}

	Module question {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Answer {
			Entity Answer {
				aggregateRoot
				- Question question
				- @User user
				- AnsweredTag answeredTag
			}
			DomainEvent TagChoicesListed
			DomainEvent AnswerSubmitted {
				- @Answer answer
			}
			ValueObject AnsweredTag {
				int id
				String name
			}
		}
	}
}

BoundedContext EvaluationContext implements EvaluationDomain {
	Application {
		Command CheckAnswer
		Command CreateEvaluation
		Command AwardPointForEvaluation
		Flow EvaluationFlow {
			event AnswerSubmitted triggers command CheckAnswer
			command CheckAnswer delegates to Question emits event AnswerValidated X AnswerRefused
			event AnswerValidated triggers command CreateEvaluation
			event AnswerRefused triggers command CreateEvaluation
			command CreateEvaluation delegates to Question emits event EvaluationCreated
			command AwardPointForEvaluation delegates to Question emits event AwardedPoint
		}
	}

	Module evaluation {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Exercice {
			Entity Evaluation {
				aggregateRoot
				int score
				- @Status status
				- @Answer answer
				- @DifficultyLevel answeredQuestionDifficultyLevel
				- AnsweringUser user
			}
			DomainEvent AnswerValidated {
				- @Answer answer
			}
			DomainEvent AnswerRefused {
				- @Answer answer
			}
			DomainEvent EvaluationCreated {
				- @Evaluation evaluation
			}
			enum Status {
				aggregateLifecycle
				OPEN, DONE
			}
			enum DifficultyLevel {
				EASY, MEDIUM, HARD
			}
			ValueObject AnsweringUser {
				int id
				String name
			}
			// Valid tag of question resource
			ValueObject EvaluationTag {
				int id
				String name
			}
			ValueObject EvaluationQuestion {
				int id
			}
		}
		Aggregate PointAwardRule {
			Entity PointAwardRule {
				aggregateRoot
				- @DifficultyLevel difficultyLevel
				- @UserLevel userLevel
			}
			DomainEvent AwardedPoint {
				- @Answer answer
			}
			enum UserLevel {
				aggregateLifecycle
				NEW, REGULAR, EXPERT
			}
		}
	}
}

BoundedContext StatContext implements StatDomain {
	Application {	
		Command ViewStats
		Flow ViewStatsFlow {
			command ViewStats delegates to Question emits event UserStatsViewed X QuestionStatsViewed X TagStatsViewed
		}
	}

	Module statistic {
		basePackage = com.esgilyon.questionddd.domain.model
		Aggregate Statistic {
			Entity LeaderBoard {
				aggregateRoot
				- List<Evaluation> evaluation
				- List<AnsweringUser> answeringUsers
				- DifficultyLevel difficultyLevel
				- EvaluationTag tagId
			}
			DomainEvent UserStatsViewed {
				- AnsweringUser user
			}
			DomainEvent QuestionStatsViewed {
				- EvaluationQuestion question
			}
			DomainEvent TagStatsViewed {
				- EvaluationTag tag
			}
		}
	}
}
