
Domain Gamedev {
	Subdomain EvaluationDomain {
		domainVisionStatement = "Evaluation domain vision ..."
	}

	Subdomain SkillDomain {
		domainVisionStatement = "Skill domain vision ..."
	}

	Subdomain QuestionDomain {
		domainVisionStatement = "Question domain vision ..."
	}

	Subdomain StatDomain {
		domainVisionStatement = "Stat domain vision ..."
	}

}

ContextMap Poller {
	type = SYSTEM_LANDSCAPE
	state = TO_BE
	contains UserManagementContext, QuestionContext, SkillContext
	contains SendQuestionContext, AnswerContext
	contains EvaluationContext, StatContext

	// Links doc : https://contextmapper.org/docs/language-model/#links
	QuestionContext [S]->[C] SendQuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = QuestionResource
	}

	QuestionContext [P]<->[P] SkillContext {
		implementationTechnology = "RESTfulHTTP"
	}

	SkillContext [S]->[C] SendQuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = Skill
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] SendQuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] QuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] AnswerContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] SkillContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	SendQuestionContext [S]->[C] AnswerContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = UserPreferences, QuestionNotification
	}

	AnswerContext [S]->[C] EvaluationContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = Answer
	}

	EvaluationContext [S]->[C] StatContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = Exercice
	}
}

BoundedContext UserManagementContext {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow Authentication {
			command Register delegates to User [WAITING_VALIDATION -> WAITING_VALIDATION] emits event UserWaitingForValidation
			event UserWaitingForValidation triggers command ValidateUser X RejectUser
			command ValidateUser delegates to User [WAITING_VALIDATION -> VALIDATED] emits event UserValidated
			command RejectUser delegates to User [WAITING_VALIDATION -> WAITING_VALIDATION] emits event UserRejected
		}
	}
	Aggregate User {
		Entity UserInfos {
			aggregateRoot
			String firstname
			String lastname
			String password
			String mail email
			- @Roles role
			- @UserStatus status
			def void validateUser();
			def void promoteToStudent();
			def void promoteToEvaluator();
		}
		enum Roles {
			EVALUATOR, STUDENT, INQUISITOR, NONE
		}
		enum UserStatus {
			aggregateLifecycle
				VALIDATED, WAITING_VALIDATION
		}
		Command Register {
			String firstname
			String lastname
			String mail email
			String password
			- Roles role
		}
		Command ValidateUser {
			- UserInfos userInfos
		}
		Command RejectUser {
			- UserInfos userInfos
		}
		DomainEvent UserWaitingForValidation {
			- UserInfos userInfos
		}
		DomainEvent UserValidated {
			- UserInfos userInfos
		}
		DomainEvent UserRejected {
			- UserInfos userInfos
		}
	}
}

BoundedContext QuestionContext implements SkillDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		/* For event trigger in flow :
		 *   X: alternative command invokation (exclusive; only one); 
		 *   +: concurrent command invokation (all commands called); 
		 *   O: alternative command invokation (inclusive; one or multiple)
		 */
		Flow AssociateQuestionFlow {
			command CreateResource delegates to QuestionResource [WAITING -> WAITING] emits event ResourceWaitingForAssociation
			event ResourceWaitingForAssociation triggers command ValidateResourceTagLinkage X RejectResourceTag
			command ValidateResourceTagLinkage delegates to QuestionResource [WAITING -> ASSOCIATED X REFUSED] emits event ResourceAcceptedAssociation
			command RejectResourceTag delegates to QuestionResource [WAITING -> REFUSED] emits event ResourceRefusedAssociation
		}
	}
	Aggregate QuestionResource {
		Entity QuestionResource {
			aggregateRoot
			String questionContent
			- @States questionState
			- @Types resourceType
			- QuestionResourceTagInfos tagInfos
			def boolean isWaitingForAssociation();
			def boolean accept();
			def boolean refuse();
			def QuestionResource associate(@Tag tag);
		}
		enum Types {
			IMG_URL, URL, TEXT
		}
		enum States {
			aggregateLifecycle
				WAITING, ASSOCIATED, REFUSED
		}
		ValueObject QuestionResourceTagInfos {
			Long tagId
			String name
		}
		DomainEvent ResourceWaitingForAssociation {
			- QuestionResource questionId
			- QuestionResourceTagInfos tagInfos
		}
		DomainEvent ResourceAcceptedAssociation {
			- QuestionResource questionId
			- QuestionResourceTagInfos tagInfos
		}
		DomainEvent ResourceRefusedAssociation {
			- QuestionResource questionId
			- QuestionResourceTagInfos tagInfos
		}
		Command CreateResource {
			- QuestionResource questionId
		}
		Command ValidateResourceTagLinkage {
			- QuestionResource questionId
		}
		Command RejectResourceTag {
			- QuestionResource questionId
		}
	}
}

BoundedContext SkillContext implements SkillDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow CreateSkillFlow {
			command CreateCategory emits event CategoryCreated
			command CreateTag delegates to Skill [CREATED -> CREATED] emits event TagCreated
		}
	}
	Aggregate Skill {
		Entity Tag {
			aggregateRoot
			String name
			- CreatedById createdById
			def Tag setCategory(@Category category);
		}
		ValueObject TagInfos {
			Long tagId
			String name
		}
		enum TagStates {
			aggregateLifecycle
				CREATED, DELETED
		}
		Entity Category {
			String name
			String description
			- List<Tag> tags
			def Category addTag(@Tag tag);
		}
		enum CategoryEvents {
			CREATED, DELETED
		}
		ValueObject CreatedById {
			Long id
		}
		DomainEvent TagCreated {
			- Tag tagId
		}
		DomainEvent CategoryCreated {
			- Category categoryId
		}
		Command CreateTag {
			- Tag tag
		}
		Command CreateCategory {
			- Category category
		}
	}
}

BoundedContext SendQuestionContext implements QuestionDomain {
	// Ubiquitous Language for question notion is here a "notification"s
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow CreateChoiceFlow {
			// Randomized choice creation
			command PrepareQuestions delegates to QuestionNotification emits event CreatedQuestion
			event CreatedQuestion triggers command SendQuestionByTagsPreferences
			command SendQuestionByTagsPreferences delegates to QuestionNotification emits event NotifiedQuestion
		}
	}
	Aggregate UserPreferences {
		Entity UserPreferences {
			aggregateRoot
			- UserWithPreferencesId user
			- List<UserPreferencesTagInfos> preferences
			def UserPreferences addPreference(@TagInfos tagId);
		}
		ValueObject UserWithPreferencesId {
			Long userId
		}
		ValueObject UserPreferencesTagInfos {
			Long tagId
			String name
		}
	}
	Aggregate QuestionNotification {
		Entity QuestionSent {
			aggregateRoot
			- QuestionNotificationStatus status
			- List<QuestionSentTagId> tags
			Date sentDate
			Date viewedDate
			Date answeredDate
			def QuestionSent send();
			def QuestionSent view();
			def QuestionSent answer();
			- ResourceId resourceId
		}
		ValueObject QuestionSentTagId {
			Long tagId
		}
		ValueObject QuestionSentQuestionResourceTagId {
			Long tagId
		}
		ValueObject ResourceId {
			Long id
		}
		enum QuestionNotificationStatus {
			aggregateLifecycle
				SENT, VIEWED, ANSWERED
		}
		DomainEvent CreatedQuestion {
			- QuestionSent questionAndTag
		}
		DomainEvent NotifiedQuestion {
			- QuestionSent questionResource
		}
		Command PrepareQuestions {
			Integer tagToPrepareQuestions
		}
		Command SendQuestionByTagsPreferences {
			- QuestionSent questionToSend
		}
	}
}

BoundedContext AnswerContext implements QuestionDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow ChoiceSubmitFlow {
			command TagChoicesList delegates to QuestionResource emits event TagChoicesListed
			command AnswerSubmit delegates to QuestionResource emits event AnswerSubmitted
		}
	}
	Aggregate Answer {
		Entity Answer {
			aggregateRoot
			- QuestionId question
			- AnsweredTag answeredTag
			- UserId userId
		}
		ValueObject QuestionId {
			Long questionId
		}
		ValueObject AnsweredTag {
			Long tagId
			String name
		}
		ValueObject UserId {
			Long id
		}
		DomainEvent TagChoicesListed
		DomainEvent AnswerSubmitted {
			- @Answer answer
		}
		// Query
		Command TagChoicesList
		Command AnswerSubmit {
			- @Answer answer
		}
	}
}

BoundedContext EvaluationContext implements EvaluationDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow EvaluationFlow {
			event AnswerSubmitted triggers command CheckAnswer
			command CheckAnswer delegates to Exercice [OPENED -> VALID X INVALID] emits event AnswerChecked
			event AnswerChecked triggers command CreateEvaluation
			command CreateEvaluation delegates to Exercice emits event EvaluationCreated
			command AwardPointForEvaluation delegates to PointAwardRule emits event AwardedPoint
		}
	}
	Aggregate Exercice {
		Entity Evaluation {
			aggregateRoot
			int score
			- @Status status
			- EvaluationTag tag
			- EvaluationQuestion question
			- AnsweringUser user
			- @DifficultyLevel answeredQuestionDifficultyLevel
		}
		enum Status {
			aggregateLifecycle
			VALID, INVALID, OPENED
		}
		enum DifficultyLevel {
			EASY, MEDIUM, HARD
		}
		ValueObject AnsweringUser {
			Long userId
			String name
		}
		// Valid tag of question resource
		ValueObject EvaluationTag {
			Long tagId
			String name
		}
		ValueObject EvaluationQuestion {
			Long questionId
		}
		ValueObject EvaluatedAnswer {
			Long answerId
		}
		DomainEvent AnswerChecked {
			- @EvaluatedAnswer answer
		}
		DomainEvent EvaluationCreated {
			- @Evaluation evaluation
		}
		Command CheckAnswer {
			- @EvaluatedAnswer answer
		}
		Command CreateEvaluation {
			- @EvaluatedAnswer	 answer
		}
	}
	Aggregate PointAwardRule {
		Entity PointAwardRule {
			aggregateRoot
			int scoreEvolution
			- @DifficultyLevel difficultyLevel
			- @UserLevel userLevel
			def int pointsForRefusedOrValidated();
		}
		enum UserLevel {
			aggregateLifecycle
				NEW, REGULAR, EXPERT
		}
		DomainEvent AwardedPoint {
			- @EvaluatedAnswer answer
		}
		Command AwardPointForEvaluation {
			- @Evaluation evaluation
		}
	}
}

BoundedContext StatContext implements StatDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow ViewStatsFlow {
			command ViewStats delegates to QuestionResource emits event UserStatsViewed X QuestionStatsViewed X TagStatsViewed
		}
	}
	Aggregate Statistic {
		Entity LeaderBoard {
			aggregateRoot
			- List<EvaluationId> evaluation
			- DifficultyLevel difficultyLevel
			- StatisticSubjectTag tagId
		}
		ValueObject EvaluationId {
			Long evaluationId
		}
		ValueObject StatisticSubjectTag {
			Long tagId
		}
		ValueObject StatisticSubjectUser {
			Long userId
		}
		ValueObject StatisticSubjectQuestion {
			Long questionId
		}
		DomainEvent UserStatsViewed {
			- StatisticSubjectUser user
		}
		DomainEvent QuestionStatsViewed {
			- StatisticSubjectQuestion question
		}
		DomainEvent TagStatsViewed {
			- StatisticSubjectTag tag
		}
		Command ViewStats {
			- @StatisticSubjectUser user nullable
			- @StatisticSubjectQuestion question nullable
			- @StatisticSubjectTag tag nullable
		}
	}
}

