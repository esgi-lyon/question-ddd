
Domain Gamedev {
	Subdomain EvaluationDomain {
		domainVisionStatement = "Evaluation domain vision ..."
	}

	Subdomain SkillDomain {
		domainVisionStatement = "Skill domain vision ..."
	}

	Subdomain QuestionDomain {
		domainVisionStatement = "Question domain vision ..."
	}

	Subdomain StatDomain {
		domainVisionStatement = "Stat domain vision ..."
	}

}

ContextMap Poller {
	type = SYSTEM_LANDSCAPE
	state = TO_BE
	contains UserManagementContext, QuestionContext, SkillContext
	contains SendQuestionContext, AnswerContext
	contains EvaluationContext, StatContext

	// Links doc : https://contextmapper.org/docs/language-model/#links
	QuestionContext [S]->[C] SendQuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = QuestionResource
	}

	QuestionContext [P]<->[P] SkillContext {
		implementationTechnology = "RESTfulHTTP"
	}

	SkillContext [S]->[C] SendQuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = Skill
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] SendQuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] QuestionContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] AnswerContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	UserManagementContext [U, OHS, PL]->[D, ACL] SkillContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = User
	}

	SendQuestionContext [S]->[C] AnswerContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = UserPreferences, QuestionNotification
	}

	AnswerContext [S]->[C] EvaluationContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = Answer
	}

	EvaluationContext [S]->[C] StatContext {
		implementationTechnology = "RESTfulHTTP"
		exposedAggregates = Exercice
	}
}

BoundedContext UserManagementContext {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Aggregate User {
		Entity UserInfos {
			aggregateRoot
			String firstname
			String lastname
			- @Roles role
			- @UserStatus status
			def AddressId validateUser();
			def boolean promoteToStudent();
			def boolean promoteToEvaluator();
		}
		enum Roles {
			EVALUATOR, STUDENT, NONE
		}
		enum UserStatus {
			aggregateLifecycle
				VALIDATED, WAITING_VALIDATION
		}
		ValueObject UserId {
			int userId
		}
	}
}

BoundedContext QuestionContext implements SkillDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		/* For event trigger in flow :
		 *   X: alternative command invokation (exclusive; only one); 
		 *   +: concurrent command invokation (all commands called); 
		 *   O: alternative command invokation (inclusive; one or multiple)
		 */
		Flow AssociateQuestionFlow {
			command CreateResource delegates to QuestionResource [WAITING -> WAITING] emits event ResourceWaitingForAssociation
			event ResourceWaitingForAssociation triggers command ValidateResourceTagLinkage X RejectResourceTag
			command ValidateResourceTagLinkage delegates to QuestionResource [WAITING -> ASSOCIATED X REFUSED] emits event ResourceAcceptedAssociation
		}
	}
	Aggregate QuestionResource {
		Entity QuestionResource {
			aggregateRoot
			String questionContent
			- @States questionState
			- @Types resourceType
			- Tag tag
			def boolean isWaitingForAssociation();
			def boolean accept();
			def boolean refuse();
			def QuestionResource associate(@Tag tag);
		}
		enum Types {
			IMG_URL, URL, TEXT
		}
		enum States {
			aggregateLifecycle
				WAITING, ASSOCIATED, REFUSED
		}
		DomainEvent ResourceWaitingForAssociation {
			- QuestionResource questionId
			- TagInfos tagId
		}
		DomainEvent ResourceAcceptedAssociation {
			- QuestionResource questionId
			- TagInfos tagId
		}
		DomainEvent ResourceRefusedAssociation {
			- QuestionResource questionId
			- TagInfos tagId
		}
		Command CreateResource {
			- QuestionResource questionId
		}
		Command ValidateResourceTagLinkage {
			- QuestionResource questionId
		}
		Command RejectResourceTag {
			- QuestionResource questionId
		}
	}
}

BoundedContext SkillContext implements SkillDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow CreateSkillFlow {
			command CreateTag delegates to Skill [CREATED -> CREATED] emits event TagCreated
			command CreateCategory emits event CategoryCreated
		}
	}
	Aggregate Skill {
		Entity Tag {
			aggregateRoot
			String name
			- @UserInfos createdBy
			def Tag setCategory(@Category category);
		}
		ValueObject TagInfos {
			int tagId
			String name
		}
		enum TagStates {
			aggregateLifecycle
				CREATED, DELETED
		}
		Entity Category {
			String name
			String description
			- List<Tag> tags
			- @UserInfos createdBy
			def Category addTag(@Tag tag);
		}
		enum CategoryEvents {
			CREATED, DELETED
		}
		ValueObject CategoryId {
			int categoryId
		}
		DomainEvent TagCreated {
			- TagInfos tagId
		}
		DomainEvent CategoryCreated {
			- CategoryId categoryId
		}
		Command CreateTag {
			- Tag tag
		}
		Command CreateCategory {
			- Category category
		}
	}
}

BoundedContext SendQuestionContext implements QuestionDomain {
	// Ubiquitous Language for question notion is here a "notification"s
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow CreateChoiceFlow {
			// Randomized choice creation
			command CreateQuestion delegates to QuestionNotification emits event CreatedQuestion
			event CreatedQuestion triggers command SendQuestionByTagsPreferences
			command SendQuestionByTagsPreferences delegates to QuestionNotification emits event NotifiedQuestion
		}
	}
	Aggregate UserPreferences {
		Entity UserPreferences {
			aggregateRoot
			- UserId user
			- List<TagInfos> preferences
			def UserPreferences addPreference(@TagInfos tagId);
		}
	}
	Aggregate QuestionNotification {
		Entity QuestionSent {
			aggregateRoot
			- QuestionNotificationStatus status
			- List<Tag> tags
			- QuestionResource resource
			Date sentDate
			Date viewedDate
			Date answeredDate
			def QuestionSent send();
			def QuestionSent view();
			def QuestionSent answer();
		}
		enum QuestionNotificationStatus {
			aggregateLifecycle
				SENT, VIEWED, ANSWERED
		}
		DomainEvent CreatedQuestion {
			- QuestionSent questionAndTag
		}
		DomainEvent NotifiedQuestion {
			- QuestionSent questionResource
		}
		ValueObject Question {
			- List<TagInfos> tags
			- TagInfos resourceCorrectTag
		}
		Command CreateQuestion {
			- @QuestionResource resource
		}
		Command SendQuestionByTagsPreferences {
			- @QuestionSent questionSent
		}
	}
}

BoundedContext AnswerContext implements QuestionDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow ChoiceSubmitFlow {
			command TagChoicesList delegates to QuestionResource emits event TagChoicesListed
			command AnswerSubmit delegates to QuestionResource emits event AnswerSubmitted
		}
	}
	Aggregate Answer {
		Entity Answer {
			aggregateRoot
			- Question question
			- @UserInfos user
			- AnsweredTag answeredTag
		}
		ValueObject AnsweredTag {
			int tagId
			String name
		}
		DomainEvent TagChoicesListed
		DomainEvent AnswerSubmitted {
			- @Answer answer
		}
		Command TagChoicesList
		Command AnswerSubmit {
			- @Answer answer
		}
	}
}

BoundedContext EvaluationContext implements EvaluationDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow EvaluationFlow {
			event AnswerSubmitted triggers command CheckAnswer
			command CheckAnswer delegates to Exercice [OPENED -> VALID X INVALID] emits event AnswerChecked
			event AnswerChecked triggers command CreateEvaluation
			command CreateEvaluation delegates to Exercice emits event EvaluationCreated
			command AwardPointForEvaluation delegates to PointAwardRule emits event AwardedPoint
		}
	}
	Aggregate Exercice {
		Entity Evaluation {
			aggregateRoot
			int score
			- @Status status
			- EvaluationTag tag
			- EvaluationQuestion question
			- AnsweringUser user
			- @DifficultyLevel answeredQuestionDifficultyLevel
		}
		enum Status {
			aggregateLifecycle
			VALID, INVALID, OPENED
		}
		enum DifficultyLevel {
			EASY, MEDIUM, HARD
		}
		ValueObject AnsweringUser {
			int userId
			String name
		}
		// Valid tag of question resource
		ValueObject EvaluationTag {
			int tagId
			String name
		}
		ValueObject EvaluationQuestion {
			int questionId
		}
		DomainEvent AnswerChecked {
			- @Answer answer
		}
		DomainEvent EvaluationCreated {
			- @Evaluation evaluation
		}
		Command CheckAnswer {
			- @Answer answer
		}
		Command CreateEvaluation {
			- @Answer answer
		}
	}
	Aggregate PointAwardRule {
		Entity PointAwardRule {
			aggregateRoot
			int scoreEvolution
			- @DifficultyLevel difficultyLevel
			- @UserLevel userLevel
			def int pointsForRefusedOrValidated();
		}
		enum UserLevel {
			aggregateLifecycle
				NEW, REGULAR, EXPERT
		}
		DomainEvent AwardedPoint {
			- @Answer answer
		}
		Command AwardPointForEvaluation {
			- @Evaluation evaluation
		}
	}
}

BoundedContext StatContext implements StatDomain {
	type = SYSTEM
	implementationTechnology = "Java, Spring App"
	Application {
		Flow ViewStatsFlow {
			command ViewStats delegates to QuestionResource emits event UserStatsViewed X QuestionStatsViewed X TagStatsViewed
		}
	}
	Aggregate Statistic {
		Entity LeaderBoard {
			aggregateRoot
			- List<Evaluation> evaluation
			- DifficultyLevel difficultyLevel
			- EvaluationTag tagId
		}
		DomainEvent UserStatsViewed {
			- AnsweringUser user
		}
		DomainEvent QuestionStatsViewed {
			- EvaluationQuestion question
		}
		DomainEvent TagStatsViewed {
			- EvaluationTag tag
		}
		Command ViewStats {
			- @AnsweringUser user nullable
			- @EvaluationQuestion question nullable
			- @EvaluationTag tag nullable
		}
	}
}
